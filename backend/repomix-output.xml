This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.vs/mexyapp/DesignTimeBuild/.dtbcache.v2
.vs/mexyapp/v17/.suo
appsettings.json
documentacion/PlugAndPlay.md
documentacion/ReglasGlobales.docx
documentacion/RolesReglas.docx
documentacion/UsoEFCore.md
src/api/Contracts/CreateUserRequest.cs
src/api/Contracts/folderinformation.md
src/api/Contracts/UserResponse.cs.cs
src/api/documentacion.md
src/api/Endpoints/UsersEndpoints.cs
src/Infrastructure/Entities/User.cs
src/Infrastructure/Entities/UserRole.cs
src/Infrastructure/MexyContextDb.cs
src/Program.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="documentacion/PlugAndPlay.md">
PlugAndPlay

# Base de Datos

    Si queremos cambiar la base de datos a la que apunta el backend tenemos que modificar el archivo**appsettings.json**. ahi podemos especificar las credenciales tipo de base de datos y la direccion y puerto de esta, en este caso usamos supabase
</file>

<file path="documentacion/UsoEFCore.md">
// EF Core (Entity Framework Core) es un ORM de .NET

/* ¿Qué es un ORM?

   Es como un traductor entre tu código y la base de datos.

   Tú trabajas con clases (User, Product, etc.) y EF Core se encarga de:

- Convertir tus consultas LINQ en SQL
- Insertar, actualizar y borrar datos
- Mapear filas de la DB a objetos C# y viceversa

   ¿Para qué sirve?

- Evitas escribir SQL manual en cada operación
- Mapeas tablas ↔ clases
- Migraciones: actualizas el esquema desde código
- Funciona con varias DB: SQL Server, PostgreSQL, MySQL, SQLite...

   Conceptos clave:

1) DbContext → Es la “puerta” a la DB, tu sesión de trabajo

   public class AppDbContext : DbContext {

   public DbSet`<User>` Users => Set`<User>`();

   }
2) DbSet`<T>` → Representa una tabla (ej: db.Users = tabla Users)
3) LINQ → SQL

   var user = await db.Users.FirstOrDefaultAsync(x => x.Email == email);

   // EF genera: SELECT TOP(1) * FROM Users WHERE Email = ...
4) Migraciones → Scripts para crear/actualizar tablas desdecódigo

   Diferenciarápida:

   -EFclásico(EF6):viejo,ligadoa.NETFramework

   -EFCore:moderno,multiplataforma,recomendadohoy

   ¿Porqué apareceprivateUser(){}// EF?

   PorqueEFnecesitacrearobjetosUsercuandoleedelaDB.

   Eseconstructorvacíoesla “puerta” paraEF,perolohacemosprivate

   paraquenadiemáspuedacrearUsersvacíosyromperreglas.

   SinousasEFCore,opciones:

   -Dapper(másmanual,rápido)

   -SQLdirectoconADO.NET

   Paraproyectosnuevos,EFCoreaceleramuchoelCRUDymigraciones.

*/
</file>

<file path="src/api/Contracts/CreateUserRequest.cs">
namespace MexyApp.Api.Contracts;

public sealed record CreateUserRequest(string Username, string Email, string Password);

//Esto es un modelo de datos, nos sirve para saber que datos necesitamos para crear un usuario
//De esta manera mantenemos nuestro codigo limpio y organizado
</file>

<file path="src/api/Contracts/folderinformation.md">
Los contratos son como definicion de modelos, nos permite saber que datos o variables habra
en la entrada y salida, esto nos permite tener un codigo mas mantenible y reducir las probabilidades 
de que algo malo suceda
</file>

<file path="src/api/Contracts/UserResponse.cs.cs">
namespace MexyApp.Api.Contracts;

public sealed record UserResponse(
    int Id,
    string Username,
    string Email,
    string Status,
    string[] Roles
);
//Este es un modelo de datos que utilizamos para devolver la informacion del usuario
//Despues de que se ha creado o consultado un usuario
</file>

<file path="src/api/documentacion.md">
A continuación te dejo una **guía de arquitectura** para la carpeta `Api` en una solución .NET (Minimal APIs o controladores). Es “README‑style” para que la pegues en tu repo.

---

# Carpeta `Api` — responsabilidades y estructura

## Propósito

Alojar **el borde HTTP** de la aplicación: endpoints, contratos (DTOs), validación, autenticación/autorización, documentación OpenAPI, manejo de errores, telemetría y salud. Debe ser  **delgada** : no contiene lógica de negocio ni acceso a datos (eso vive en `Application`/`Infrastructure`).

## Detalle por carpeta

### `Program.cs`

Compone el **pipeline HTTP** y registra servicios:

* `UseAuthentication()`, `UseAuthorization()`; `[Authorize]` sobre endpoints/policies. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/ef/core/modeling/value-conversions)
* **OpenAPI** (`AddOpenApi`, `MapOpenApi`) y **Swagger UI/Scalar solo en `Development`** (reduce exposición). [[learn.microsoft.com]](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-10.0), [[learn.microsoft.com]](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.isession?view=aspnetcore-10.0)
* **Health checks** (`AddHealthChecks`, `MapHealthChecks("/health")`). [[learn.microsoft.com]](https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-10.0)
* **Logging** (`ILogger` o Serilog) con niveles y no PII. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.ipasswordhasher-1?view=aspnetcore-10.0)

> Minimal APIs usa **route groups** y **WithOpenApi** para describir endpoints. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/answers/questions/2279797/persisting-data-through-session)

---

### `Endpoints/` (o `Controllers/`)

Los endpoints  **orquestan** : reciben DTOs, validan, llaman a `Application` y devuelven códigos HTTP apropiados.

* Minimal APIs: agrupa por recurso (`/users`, `/roles`) y documenta con `.WithOpenApi()`. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/answers/questions/2279797/persisting-data-through-session)
* Controladores MVC: `[ApiController]` + `[Authorize]` + atributos de respuesta.

**Ejemplo (Minimal API):**

publicstaticclassUsersEndpoints

{

    publicstaticIEndpointRouteBuilderMapUsers(thisIEndpointRouteBuilderroutes)

    {

    vargroup=routes.MapGroup("/users").WithTags("Users");

    group.MapPost("/",CreateUser).Produces(201).WithOpenApi();

    group.MapGet("/{id:int}",GetUser).Produces(200).Produces(404).WithOpenApi();

    // …

    returnroutes;

    }

}

---

### `Contracts/`

Define **DTOs** de entrada/salida. Añade **DataAnnotations** (o FluentValidation) para reglas básicas; en controladores con `[ApiController]` obtienes **400 automático** si el modelo es inválido. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/answers/questions/2114933/how-to-validate-security-stamp-on-next-request)

---

### `Validation/`

Validación adicional (p.ej. FluentValidation) o validación de negocio superficial para rechazar rápido.

> En web APIs, mantener las reglas de formato/tamaño aquí y las reglas de negocio profundas en `Application`. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/answers/questions/2114933/how-to-validate-security-stamp-on-next-request)

---

### `Auth/`

* **Policies** (claims/roles) con `AddAuthorization`, `RequireClaim`, `RequireRole`, `RequireAssertion`. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/answers/questions/390717/how-to-combine-one-to-many-relationship-and-many-t)
* **Roles** : `[Authorize(Roles="Administrador,Soporte")]` donde aplique. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-5.0/whatsnew)
* **Tokens/cookies** : configura esquemas en `Program.cs` y usa claims para autorización. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/ef/core/modeling/value-conversions)

---

### `Middleware/`

Cross‑cutting:

* **Global exception handler** → 500 consistente + problema (RFC7807) en JSON.
* **Request/Response logging** y **Correlation ID** (cabecera `X-Correlation-ID`).
* **Rate limiting** si procede.

> Logging con `ILogger` o Serilog; evita PII y usa niveles adecuados. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.ipasswordhasher-1?view=aspnetcore-10.0)

---

### `OpenApi/`

Configura la generación de documento y UI (Swagger/Scalar).  **Habilitar UI sólo en `Development`** . Documenta respuestas (`Produces`) y esquemas. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-10.0), [[learn.microsoft.com]](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.isession?view=aspnetcore-10.0)

---

### `Health/`

Registra sondas de **liveness** y **readiness** (DB, servicios externos) y expone `/health`. Útil para orquestadores y balanceadores. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-10.0)

---

### `Versioning/` (opcional)

Si tu API tendrá múltiples versiones, organiza route groups por versión (`/v1`, `/v2`) y etiqueta OpenAPI por versión. Guía general de versionado/semver para paquetes/bibliotecas. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/aspnet/core/performance/overview?view=aspnetcore-10.0)

---

### `Mapping/` (opcional)

Perfiles de AutoMapper para mapear entidades ↔ DTOs. Mantén el mapeo simple en la capa `Api`.

---

### `appsettings.json` (sin secretos)

Solo **configuración no sensible** (logging, OpenAPI, flags). **No** metas credenciales: usa **variables de entorno** en dev y **Azure Key Vault** en prod; si despliegas en Azure, considera **Managed Identity** para acceso a recursos sin secretos. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/dotnet/api/system.security.claims.claimsprincipal?view=net-10.0), [[learn.microsoft.com]](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/best-practices?view=aspnetcore-10.0), [[learn.microsoft.com]](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/claims?view=aspnetcore-10.0)

---

## Reglas de diseño de API (resumen)

* **Idempotencia** : `GET/PUT/DELETE` idempotentes; `POST` para crear.
* **Códigos HTTP y contratos** : usa `Results.*`/`Produces()` con OpenAPI. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/answers/questions/2279797/persisting-data-through-session)
* **Paginación, filtro, orden** para colecciones grandes (evita payloads enormes). [[learn.microsoft.com]](https://learn.microsoft.com/en-us/answers/questions/1476624/using-serilog-in-asp-net-core-solution-with-multip)
* **Autorización declarativa** con roles/policies; evita consultas a BD por request para “quién es/qué puede”. Claims en token/cookie + revalidación de security stamp. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/ef/core/modeling/value-conversions), [[learn.microsoft.com]](https://learn.microsoft.com/en-us/answers/questions/390717/how-to-combine-one-to-many-relationship-and-many-t)
* **Observabilidad** : logs estructurados por request y  **health checks** . [[learn.microsoft.com]](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.ipasswordhasher-1?view=aspnetcore-10.0), [[learn.microsoft.com]](https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-10.0)

---

## Qué **debe llevar** hoy tu carpeta `Api` (según tu repo actual)

* `Program.cs` con:
  * Registro de `MexyContext` y servicios.
  * Endpoints `Users`/`Roles` (Minimal APIs) con DTOs y validación.
  * `AddOpenApi` + `MapOpenApi`  **solo en dev** . [[learn.microsoft.com]](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-10.0)
  * `AddHealthChecks()` + `MapHealthChecks("/health")`. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-10.0)
  * Logging básico (`AddConsole`).
* `Endpoints/UsersEndpoints.cs` y `Endpoints/RolesEndpoints.cs` para ordenar rutas. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/answers/questions/2279797/persisting-data-through-session)
* `Contracts/` con `CreateUserDto`, `UserResponse`, `RoleDto`.
* `Validation/` (si amplías más allá de DataAnnotations). [[learn.microsoft.com]](https://learn.microsoft.com/en-us/answers/questions/2114933/how-to-validate-security-stamp-on-next-request)
* `Auth/Policies.cs` si empiezas a proteger endpoints por roles/políticas. [[learn.microsoft.com]](https://learn.microsoft.com/en-us/answers/questions/390717/how-to-combine-one-to-many-relationship-and-many-t)
* `OpenApi/OpenApiConfig.cs` (opcional) para centralizar la configuración de tags, descriptions y `Produces`.
* `Health/HealthConfig.cs` (opcional) para chequear DB/externos.
* `appsettings.json` **sin secretos** (mover credenciales a env/Key Vault). [[learn.microsoft.com]](https://learn.microsoft.com/en-us/dotnet/api/system.security.claims.claimsprincipal?view=net-10.0), [[learn.microsoft.com]](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/best-practices?view=aspnetcore-10.0)

---

## Siguiente paso rápido

Si quieres, preparo un **README.md** listo para tu `src/Api/` con esta estructura, más un ejemplo completo de `UsersEndpoints` (Minimal API + OpenAPI + validación) y el registro de health/logging en `Program.cs`. ¿Lo dejo con DataAnnotations o prefieres FluentValidation?
</file>

<file path="src/api/Endpoints/UsersEndpoints.cs">
// src/api/Endpoints/UsersEndpoints.cs
using Microsoft.EntityFrameworkCore;
using MexyApp.Api.Contracts;
using MexyApp.Api.Domain;
using Npgsql;
using System.Net.Sockets;

namespace MexyApp.Api.Endpoints;

public static class UsersEndpoints
{
    private static readonly string[] EmailUniqueConstraintNames =
    {
        "IX_Users_Email", "users_email_key", "Users_Email_key"
    };

    private static bool IsUniqueEmailViolation(DbUpdateException ex)
    {
        var pg = ex.InnerException as PostgresException;
        return pg?.SqlState == "23505"
            && !string.IsNullOrEmpty(pg.ConstraintName)
            && (EmailUniqueConstraintNames.Any(n => pg.ConstraintName.Equals(n, StringComparison.OrdinalIgnoreCase))
                || pg.ConstraintName.Contains("email", StringComparison.OrdinalIgnoreCase));
    }

    private static bool IsTimeout(DbUpdateException ex)
    {
        // Detecta Timeout en la cadena de inner exceptions
        Exception? cur = ex;
        while (cur is not null)
        {
            if (cur is TimeoutException) return true;
            if (cur is NpgsqlException npg && npg.InnerException is TimeoutException) return true;
            if (cur is IOException io && io.InnerException is TimeoutException) return true;
            if (cur is SocketException se && se.SocketErrorCode == SocketError.TimedOut) return true;
            cur = cur.InnerException;
        }
        return false;
    }

    private static string Describe(DbUpdateException ex)
    {
        var pg = ex.InnerException as PostgresException;
        return pg is null
            ? $"Inner={ex.InnerException?.GetType().Name ?? "null"}; Msg={ex.InnerException?.Message ?? "null"}"
            : $"SqlState={pg.SqlState}; Constraint={pg.ConstraintName ?? "null"}; Table={pg.TableName ?? "null"}; Detail={pg.Detail ?? "null"}";
    }

    public static IEndpointRouteBuilder MapUsersEndpoints(this IEndpointRouteBuilder routes)
    {
        var group = routes.MapGroup("/api/users").WithTags("Users");

        group.MapPost("/", async (CreateUserRequest req, MexyContext db, CancellationToken ct) =>
        {
            if (string.IsNullOrWhiteSpace(req.Username) ||
                string.IsNullOrWhiteSpace(req.Email) ||
                string.IsNullOrWhiteSpace(req.Password))
                return Results.BadRequest("Username, Email y Password son obligatorios.");

            var email = req.Email.Trim().ToLowerInvariant();

            // Baja el costo mientras diagnosticas (ver sección 3)
            var hash = BCrypt.Net.BCrypt.HashPassword(req.Password, workFactor: 4);

            var user = new MexyApp.Models.User(req.Username, email, hash);
            db.Users.Add(user);

            try
            {
                await db.SaveChangesAsync(ct);
            }
            catch (DbUpdateException ex) when (IsUniqueEmailViolation(ex))
            {
                return Results.Conflict($"Email '{email}' ya está registrado.");
            }
            catch (DbUpdateException ex) when (IsTimeout(ex))
            {
                // Falla transitoria (red/latencia). Devuelve 503 para reintento del cliente.
                return Results.Problem(
                    title: "Timeout al persistir en la base de datos",
                    detail: Describe(ex),
                    statusCode: StatusCodes.Status503ServiceUnavailable
                );
            }
            catch (DbUpdateException ex)
            {
                // Otra restricción / error no categorizado
                return Results.Problem(
                    title: "Error al persistir usuario",
                    detail: Describe(ex),
                    statusCode: StatusCodes.Status500InternalServerError
                );
            }

            var dto = new UserResponse(
                user.Id,
                user.Username,
                user.Email,
                user.Status.ToString(),
                user.Roles.Select(r => r.ToString()).ToArray()
            );

            return Results.Created($"/api/users/{user.Id}", dto);
        });

        group.MapGet("/{id:int}", async (int id, MexyContext db, CancellationToken ct) =>
        {
            var user = await db.Users
                .AsNoTracking()
                .Include("_userRoles")
                .FirstOrDefaultAsync(u => u.Id == id, ct);

            if (user is null) return Results.NotFound();

            var dto = new UserResponse(
                user.Id,
                user.Username,
                user.Email,
                user.Status.ToString(),
                user.Roles.Select(r => r.ToString()).ToArray()
            );

            return Results.Ok(dto);
        });

        return routes;
    }
}
</file>

<file path="src/Infrastructure/Entities/User.cs">
namespace MexyApp.Models;

public enum RoleName { Comprador, Artesano, Soporte, Administrador }
public enum UserStatus { Activo, Bloqueado }

public class User
{
    public int Id { get; private set; }

    public string Username { get; private set; } = default!;
    public string Email { get; private set; } = default!;
    public string PasswordHash { get; private set; } = default!;

    public UserStatus Status { get; private set; } = UserStatus.Activo;

    // Backing field: única fuente de verdad para la relación 1..N
    private readonly List<UserRole> _userRoles = new();

    // Proyección de nombres de rol (solo lectura)
    public IReadOnlyCollection<RoleName> Roles =>
        _userRoles.Select(ur => ur.Role).ToArray();

    private User() { } // EF

    
public User(string username, string email, string passwordHash)
{
    Username = username.Trim();
    Email = email.Trim().ToLowerInvariant();
    PasswordHash = passwordHash;

    // Rol base por defecto con guardia
    if (!_userRoles.Any(r => r.Role == RoleName.Comprador))
        _userRoles.Add(new UserRole { Role = RoleName.Comprador });
}


    public bool HasRole(RoleName role) => _userRoles.Any(r => r.Role == role);

    public void AddRole(RoleName role)
    {
        if (HasRole(role)) return; // Evita duplicados
        _userRoles.Add(new UserRole { Role = role });
    }

    public void RemoveRole(RoleName role)
    {
        var link = _userRoles.FirstOrDefault(r => r.Role == role);
        if (link is not null) _userRoles.Remove(link);
    }

    public void Block() => Status = UserStatus.Bloqueado;
}
</file>

<file path="src/Infrastructure/Entities/UserRole.cs">
namespace MexyApp.Models;

public class UserRole
{
    public int UserId { get; set; }
    public RoleName Role { get; set; }
    public User? User { get; set; } // navegación opcional

    public UserRole() { } // constructor vacío para EF
}
</file>

<file path="src/Infrastructure/MexyContextDb.cs">
using Microsoft.EntityFrameworkCore;
using MexyApp.Models;

namespace MexyApp.Api.Domain
{
    public sealed class MexyContext : DbContext
    {
        public MexyContext(DbContextOptions<MexyContext> options) : base(options) { }

        public DbSet<User> Users => Set<User>();
        public DbSet<UserRole> UserRoles => Set<UserRole>();

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.HasDefaultSchema("public"); // explícito para Supabase

            modelBuilder.Entity<User>(b =>
            {
                b.ToTable("Users");
                b.HasKey(u => u.Id);

                b.Property(u => u.Username).HasMaxLength(100).IsRequired();
                b.Property(u => u.Email).HasMaxLength(256).IsRequired();
                b.HasIndex(u => u.Email).IsUnique();

                b.Property(u => u.PasswordHash).HasMaxLength(256).IsRequired();

                b.Property(u => u.Status)
                 .HasConversion<string>()
                 .HasMaxLength(20)
                 .IsRequired();

                // Relación 1..N usando backing field "_userRoles" (no hay propiedad de navegación pública)
                b.HasMany<UserRole>("_userRoles")
                 .WithOne(ur => ur.User)
                 .HasForeignKey(ur => ur.UserId)
                 .OnDelete(DeleteBehavior.Cascade);

                b.Navigation("_userRoles")
                 .UsePropertyAccessMode(PropertyAccessMode.Field);
            });

            modelBuilder.Entity<UserRole>(b =>
            {
                b.ToTable("UserRoles");

                // Unicidad por (UserId, Role)
                b.HasKey(ur => new { ur.UserId, ur.Role });

                b.Property(ur => ur.Role)
                 .HasConversion<string>()
                 .HasMaxLength(50)
                 .IsRequired();
            });
        }
    }
}
</file>

<file path="src/Program.cs">
// src/Program.cs
using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using MexyApp.Api.Domain;
using MexyApp.Api.Endpoints;

var builder = WebApplication.CreateBuilder(args);

// ==========================================
// FLUJO PRINCIPAL (MAIN)
// ==========================================

// 1) Cargar configuración desde appsettings.json (sin usar connString aquí)
ConfigureAppConfiguration(builder);

// 2) Obtener cadena de conexión final
string connString = GetAndParseConnectionString(builder.Configuration, builder.Environment.ContentRootPath);

// 3) Registrar servicios (usa connString)
RegisterServices(builder, connString);

// 4) Construir la app
var app = builder.Build();
app.Logger.LogInformation("Inicio de aplicación. Configuración cargada.");

// 5) Mapear endpoints
RegisterEndpoints(app);

// 6) Verificación de salud previa al arranque (crashea si no conecta)
await VerifyDatabaseConnection(app);

// 7) Arrancar
app.Run();


// ==========================================
// FUNCIONES
// ==========================================

/// <summary>
/// Limpia las fuentes y carga exclusivamente appsettings.json.
/// </summary>
void ConfigureAppConfiguration(WebApplicationBuilder builder)
{
    builder.Configuration.Sources.Clear();

    var appsettingsPath = Path.Combine(builder.Environment.ContentRootPath, "appsettings.json");
    if (!File.Exists(appsettingsPath))
        throw new FileNotFoundException($"No se encontró appsettings.json en: {appsettingsPath}");

    builder.Configuration.AddJsonFile(appsettingsPath, optional: false, reloadOnChange: false);
}

/// <summary>
/// Resuelve la cadena de conexión. Prioriza 'ConnectionStrings:Default'.
/// Si no existe, parsea 'ConnectionStrings:DefaultUri' (URI Postgres → Npgsql).
/// </summary>
string GetAndParseConnectionString(ConfigurationManager configuration, string rootPath)
{
    string? connString = configuration.GetConnectionString("Default");

    if (string.IsNullOrWhiteSpace(connString))
    {
        var uri = configuration["ConnectionStrings:DefaultUri"];
        if (string.IsNullOrWhiteSpace(uri))
            throw new InvalidOperationException(
                $"Falta ConnectionStrings:Default o ConnectionStrings:DefaultUri en appsettings.json en {rootPath}."
            );

        connString = ParsePostgresUriToNpgsql(uri);
    }

    return connString!;
}

/// <summary>
/// Registra DbContext (pool) y Logging. Sin reintentos mientras diagnosticas.
/// </summary>
void RegisterServices(WebApplicationBuilder builder, string connString)
{
    builder.Services.AddDbContextPool<MexyContext>(opt =>
    {
        opt.UseNpgsql(connString, npgsql =>
        {
            // Evita “permas” en comandos largos bajo latencia
            npgsql.CommandTimeout(25);
                npgsql.EnableRetryOnFailure(5, TimeSpan.FromSeconds(2), null);

             // MaxBatchSize(1) -> retirar (mantén fuera salvo diagnóstico puntual)

            // Actívalo luego de estabilizar si quieres reintentos:
            // npgsql.EnableRetryOnFailure(5, TimeSpan.FromSeconds(2), null);
        });

        // Más detalle en dev para diagnosticar
        if (builder.Environment.IsDevelopment())
        {
            opt.EnableDetailedErrors();
            opt.EnableSensitiveDataLogging();
        }
    });

    builder.Logging.ClearProviders();
    builder.Logging.AddConsole();
    if (builder.Environment.IsDevelopment())
        builder.Logging.AddDebug();
}

/// <summary>
/// Define los endpoints de la API.
/// </summary>
void RegisterEndpoints(WebApplication app)
{
    app.MapUsersEndpoints();
}

/// <summary>
/// Ping a la DB antes de abrir el servidor.
/// </summary>
async Task VerifyDatabaseConnection(WebApplication app)
{
    var ok = await PingDatabaseAsync(app.Services, app.Logger);
    if (ok)
        app.Logger.LogInformation("Ping DB: OK");
    else
        throw new InvalidOperationException("Ping DB: ERROR de conexión. Verifica host/puerto/credenciales/SSL en appsettings.json.");
}

// ---------------------------------------------------------
// HELPERS
// ---------------------------------------------------------

static async Task<bool> PingDatabaseAsync(IServiceProvider services, ILogger logger)
{
    using var scope = services.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<MexyContext>();

    try
    {
        var can = await db.Database.CanConnectAsync();
        if (!can)
            logger.LogError("CanConnectAsync devolvió false (verifica host/puerto/credenciales/SSL).");
        return can;
    }
    catch (Exception ex)
    {
        logger.LogError(ex, "Excepción durante Ping a la DB");
        return false;
    }
}

/// <summary>
/// Convierte un URI Postgres (postgres://user:pass@host:port/db) a cadena Npgsql.
/// </summary>
static string ParsePostgresUriToNpgsql(string uri)
{
    // 1. Limpieza básica
    var v = uri.Trim();
    if (v.StartsWith("postgres://")) v = v.Substring("postgres://".Length);
    else if (v.StartsWith("postgresql://")) v = v.Substring("postgresql://".Length);
    else throw new InvalidOperationException("El URI debe iniciar con 'postgres://' o 'postgresql://'.");

    // 2. Separar credenciales (@)
    var atIndex = v.LastIndexOf('@'); // Usamos LastIndexOf por si la contraseña tiene '@'
    if (atIndex <= 0) throw new InvalidOperationException("No se encontró '@' separando credenciales del host.");

    var userInfo = v.Substring(0, atIndex);
    var hostData = v.Substring(atIndex + 1);

    // 3. Separar Usuario y Contraseña (:)
    var colonIndex = userInfo.IndexOf(':');
    if (colonIndex <= 0) throw new InvalidOperationException("No se encontró ':' entre usuario y contraseña.");
    
    var username = userInfo.Substring(0, colonIndex);
    var password = userInfo.Substring(colonIndex + 1);

    // 4. Separar Host y Base de Datos (/)
    var slashIndex = hostData.IndexOf('/');
    if (slashIndex <= 0) throw new InvalidOperationException("No se encontró '/' antes de la base de datos.");

    var hostPort = hostData.Substring(0, slashIndex);
    var dbAndParams = hostData.Substring(slashIndex + 1);

    // 5. Separar Nombre de DB y Parámetros (?)
    string database;
    string paramsString = "";

    var questionMarkIndex = dbAndParams.IndexOf('?');
    if (questionMarkIndex >= 0)
    {
        database = dbAndParams.Substring(0, questionMarkIndex);
        // Convertimos el formato URL (&) al formato Npgsql (;)
        paramsString = dbAndParams.Substring(questionMarkIndex + 1).Replace('&', ';');
    }
    else
    {
        database = dbAndParams;
    }

    // 6. Manejo del Puerto
    string host = hostPort;
    string port = "5432";
    
    var portColon = hostPort.LastIndexOf(':');
    if (portColon >= 0)
    {
        host = hostPort.Substring(0, portColon);
        port = hostPort.Substring(portColon + 1);
    }

    // 7. Construir cadena final
    // Nota: Agregamos paramsString al final para que KeepAlive, SSL, etc. se apliquen
    return $"Host={host};Port={port};Database={database};Username={username};Password={password};{paramsString}";
}
</file>

</files>
